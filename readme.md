Операторы
```
Обозначим через @(k) сдвиг на k ячеек вправо, если k>0, и влево, если k<0
    Соответственно, @(k) = >…k раз…> либо <…-k раз…<  

zero(): обнуление текущей ячейки:
    [-]
    =
    [+]

add(k): прибавление значения ячейки n (текущей) к значению ячейки n+k:
    [ — @(k)  + @(-k)  ]
    при этом значение ячейки n теряется (обнуляется).

addN(k, N): прибавление значения ячейки N к значению ячейки n+k:
    @(k)+...+@(-k)

mov(k): копирование значения ячейки n (текущей) в ячейку n+k с потерей (обнулением) значения ячейки n:
    @(k) zero() @(-k) add(k)
    =
    @(k) [-] @(-k) [ — @(k)  + @(-k)  ] 

copy(k,t): копирование значения ячейки n (текущей) в ячейку n+k c использованием промежуточной ячейки n+k+t, благодаря чему значение ячейки n не теряется (сохраняется).
    @(k) zero() @(t) zero() @(-k-t) [ — @(k) + @(t) + @(-k-t) ] @(k+t) mov(-k-t)
    =
    @(k) [-] @(t) [-] @(-k-t) [ — @(k) + @(t) + @(-k-t) ] @(k+t) [ — @(-k-t) + @(k+t) ]

copy(k,t): копирование значения ячейки n (текущей) в ячейку n+k c использованием промежуточной ячейки n+t, благодаря чему значение ячейки n не теряется (сохраняется).
    set(k,0)

ifelse(t){true}{false}: если текущая ячейка>0, то выполняется условие true если текущая ячейка=0, то выполняется условие false t-относительный номер вспомогательной ячейки, при этом внутренние программы должны возвращать каретку на то же место, откуда начинали:
    @(t)[-]+@(-t) устанавливаем флаг 1 для случая else
    [
        здесь действия ветки true
        @(t)[-]@(-t) устанавливаем флаг 0 для случая else
        [-] выход из цикла
    ]
    @(t)
    [
        @(-t)
        здесь действия ветки false
        @(t)[-] выход из цикла
    ]
    @(-t-1)

ifeq(N, t){true}{false}: Если текущая ячейка == N, то выполняется условие true, иначе -- false
    addN(0,-N)
    ifelse(t){false}{true}
    addN(0,N)

ifeqchar(ch, t){true}{false}: Если текущая ячейка == ord(ch), то выполняется условие true, иначе -- false
    ifeq(ord(ch),t)

loop(k){prg}: Выполняет цикл, пока mem[n+k] != 0. prg должна возвращать каретку на то же место, откуда начинали:
    @(k) [ @(-k) prg @(k) ]

loopFor(k){prg}: Выполнить цикл mem[n+k] раз, значение обнуляется:
    @(k) [ @(-k) prg @(k) - ]

loopForSave(k,t){prg}: Выполнить цикл mem[n+k] раз, сохранив значение n+k с использованием промежуточной ячейка n+t. mem[n+t] становится 0.
    copy(k,t) loopFor(k){prg} copy(t,k) set(t,0)

set(k,v): Установить значение ячейки n+k равной v
    @(k)[-] +...+/-...- @(-k)

setchar(k,ch): Установить значеение ячейка n+k равной ord(ch)
    set(k, ord(ch))

```